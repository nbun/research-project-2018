%\documentclass[a4paper, 11pt, fleqn, twoside]{scrreprt}
\documentclass[a4paper, 11pt, fleqn]{scrreprt}
% escapeinside
%\usepackage[gray]{xcolor}
\usepackage[T1]{fontenc}        % T1-Fonts
\usepackage[utf8]{inputenc}     % Enkodierung
\usepackage[english]{babel}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{proof} % http://www.logicmatters.net/resources/ndexamples/proofsty.html
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{natbib}
\usepackage{verbatim}
\usepackage[automark, headsepline]{scrlayer-scrpage}

% Kapitelüberschrift in der Kopfzeile
%\usepackage[automark]{scrpage2} % Schickerer Satzspiegel mit KOMA-Script
%\pagestyle{scrheadings}

% Minted
\usepackage{minted}
\usemintedstyle[haskell]{trac}
\newminted{haskell}{fontsize=\small}
\newminted{coq}{fontsize=\small}
\setmintedinline{style = bw}
\DeclareUnicodeCharacter{222A}{$\cup$}

\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\makeatother

% Für schönere Tabellen (optional)
% \usepackage{booktabs}           % Netteres Tabellenlayout
% \usepackage{multicol}           % Mehrspaltige Bereiche
% \usepackage{tabularx}           % Tabellen mit fester Breite

% Für Listings
% \usepackage{listings}

% Eine kleine Hilfe für offene Lücken
\newcommand{\todo}[1]{\marginpar{\textbf{TODO:} #1}}
\newcommand{\cinline}[1]{\mintinline{haskell}{#1}}

\begin{document}

\pagenumbering{roman} % römische Seitenzahlen

\begin{titlepage}
	\vspace*{3cm}
	\centering
	{\huge\bfseries Synthesizing Set Functions: Implementation \par}
	\vspace{1cm}
	\textbf{Research Project Report} \par 
	\vspace{6cm}
	\textbf{Niels Bunkenburg} \par
	Programming Languages and Compiler Construction \par
	Department of Computer Science \par
	Kiel University
	\vfill
	Advised by\par
	Prof. Dr. Michael Hanus \par
	M. Sc. Finn Teegen
	\vfill
	% Randloses Drucken nicht möglich...
	\tikz[remember picture,overlay] \node[opacity=0.3,inner sep=0pt] at (9.5,-1.5){\includegraphics{images/cau-siegel-1400.png}};
	{\large \today\par}
\end{titlepage}
\begin{comment}
\chapter*{Erklärung der Urheberschaft}
\vspace{2cm}
Ich erkläre hiermit an Eides statt, dass ich die vorliegende Arbeit
ohne Hilfe Dritter und ohne Benutzung anderer als der angegebenen
Hilfsmittel angefertigt habe. Aus fremden Quellen direkt oder
indirekt übernommene Gedanken sind als solche kenntlich gemacht. Die
Arbeit wurde bisher in gleicher oder ähnlicher Form in keiner anderen
Prüfungsbehörde vorgelegt und auch noch nicht veröffentlicht.

\vspace{4cm}
\hspace{1cm} $\overline{~~~~~~~~~~\mbox{Ort, Datum}~~~~~~~~~~}$ \hfill $\overline{~~~~~~~~~~~~~\mbox{Unterschrift}~~~~~~~~~~~~~}$ \hspace{1cm}

\newpage
\mbox{}
\thispagestyle{empty}
\newpage
\end{comment}
% Verzeichnisse
\renewcommand{\contentsname}{Contents}
\tableofcontents   % Inhaltsverzeichnis
%\listoffigures     % Abbildungsverzeichnis
% \listoftables      % Tabellenverzeichnis
% \lstlistoflistings % Abbildungsverzeichnis

\newpage               % Expliziter Umbruch für Seitenzahlen
\pagenumbering{arabic} % arabische Seitenzahlen

\chapter{Introduction}
When presented with a choice, we usually get to experience only one outcome of it. Whether the decision is about what to eat for lunch, where to live or what career to pursue, we have to decide and can only wonder what would have happened if we picked differently. Would not it be nice if we could collect all outcomes of a decision and pick the most appealing one?

While it is hard to imagine that we someday might be able to pick our lunch based on the recommendation of alternate reality versions of ourselves, the concept is far more tangible in the context of functional logic programming languages. A nondeterministic calculation like \cinline{0?1} can yield several values, \cinline{0} and \cinline{1} in this case. Maybe we would like to count the results or check if a specific outcome is possible? A nondeterministic expression in Curry does not "look" different than a deterministic one, at least in regard to their types. Based on this, checking if \cinline{0?1} can be evaluated to a certain result yields a naive implementation.
\begin{minted}{haskell}
isOne :: Int -> Bool
isOne x = x == 1

check :: Bool
check = isOne (0?1)
\end{minted}
The intention behind this code is that we would like to know if a value of \cinline{0?1} equals one. Unfortunately this is not what the program does. Instead, the function \cinline{check} becomes nondeterministic too and yields \cinline{True} and \cinline{False} because \cinline{isOne} is evaluated for every possible value of \cinline{0?1}. To express what we originally intended, we need to encapsulate the nondeterminism that might occur in the argument of \cinline{isOne}. This is the purpose of \textit{set functions}. A set function returns all values of a nondeterministic expression as a set that can be manipulated like a normal data structure.

\begin{minted}{haskell}
evalOne :: Int -> Bool
evalOne x = valueOf 1 (set0 x)
\end{minted}

Curry systems like KiCS2 or PAKCS implement set functions in the respective target language, that is, tree-like structures in Haskell and \cinline{findall} in Prolog. This entails slight differences when it comes to handling failures and nonterminating evaluations. Ideally, set functions would be implemented on a higher level, that is, directly in Curry. A recent publication by \citet{synsf} tackles this problem and presents a technique to synthesize the set function $f_S$ of a given $f$. Based on this, the process of building a working prototype is documented in this report. We begin with the general approach and a rough overview of the development process followed by a more detailed look at the implementation and it's limitations, concluded by a final chapter about the results and future improvements.
\chapter{Approach}
The research project is divided into two major parts: Familiarizing with the general topic of set functions by means of a prototype version of "KiCS2.5" and the implementation of a prototype based on Synthesizing Set Functions.
\section{Time line}
The project lasted from April to October 2018. Below is a short overview of what happened in each month.

\begin{itemize}
	\item April marked the start of the project and began with articles by \citet{Antoy:2009:SFF:1599410.1599420} as well as \citet{Christiansen2013ASF}. The former describes the semantics of set functions by means of a graph rewriting system while the latter defines an operational semantics. The papers represented a rather abstract introduction of the topic and were supplemented by a first look at the KiCS2 set function implementation.
	\item May started with a discussion about an issue\footnote{https://git.ps.informatik.uni-kiel.de/curry/kics2/issues/15} of KiCS2's set function implementation. The idea of finding and fixing this problem was abandoned due to the complexity of the existing implementation. Instead, working on a minimal implemtation\footnote{https://git.informatik.uni-kiel.de/fte/proto\_kics} of KiCS2 seemed like a good way to gain a deeper understanding of set functions. The addition of set functions was based upon the implementation presented by \citet{Brassel2010ImplementingFL}.
	\item June was the first month with some code output\footnote{https://git.informatik.uni-kiel.de/stu114713/proto\_kics/}. Along the way of adapting Braßel's implementation, functions to pull up choices to the root of an expression and a normal form transformation were needed. To test the new implementation, the existing examples\footnote{https://git.ps.informatik.uni-kiel.de/curry/kics2/blob/master/testsuite/LibraryTests/testSetFunctions.curry} would have been a good choice but it became apparent that due to the minimalism of the prototype, this would have been a difficult task for the more complex examples. Mid-month the exam preparation period started and the project was paused.
    \item In July nothing noteworthy -- in regard to the project -- happened.
    \item August marked the end of the first part of the project. The KiCS2.5 set function implementation worked for a simple example but had problems with the duplication of cover information which is used in Braßel's implementation to distinguish different levels of encapsulation. Since the final version of Synthesizing Set Functions was available, the second half of the project began. The goal was to implement a tool that transforms a function within a FlatCurry program into an AbstractCurry program that contains the synthesized set function based on the top-level sharing library. The month ended with the implementation of the plural function transformation.
    \item September yielded the implementation of totalizing partial functions and the generation of normal form instances. Due to a misunderstanding, the instance generation generated FlatCurry expressions which unnecessarily complicated the code due to the lack of type classes. Ultimately, the experience proved to be helpful in the implementation of  multi-parameter type class instances. To make the code more readable, the transformation was adapted to run within the \cinline{StateT} monad. It was discovered that KiCS2 cannot handle the monad instance required to define \cinline{StateT}.  Therefore, PAKCS was used for the remainder of the project.
    \item October represented the last part of the project. After implementing the multi-parameter class instances for \cinline{toValST} and \cinline{FromValST} as well as \cinline{toST} and \cinline{FromST}, some issues regarding generated function names and the selection of appropriate instance arguments for polymorphic instances were fixed. Finally, all parts of the puzzle were pieced together and resulted in the first prototype of the set function synthesizer. As a last step, sharing was implemented. 
\end{itemize}
In the next chapter, we explore the design decisions and implementation of the tool.
\chapter{Implementation}
\section{Design decisions}
Why FlatCurry -> AbstractCurry?
\section{Synthesizing phases}
\section{Examples}
\section{Limitations}

\chapter{Conclusion}


% Literatur
\bibliographystyle{plainnat}
\bibliography{ResearchProject18}
\appendix
\chapter{Repository}
\end{document}